/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2022 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>

typedef struct
{
	volatile uint32_t MODER;
	volatile uint32_t OTYPER;
	volatile uint32_t OSPEEDR;
	volatile uint32_t PUPDR;
	volatile uint32_t IDR;
	volatile uint32_t ODR;
	volatile uint32_t BSRR;
	volatile uint32_t LCKR;
	volatile uint32_t AFR[2];
	volatile uint32_t BRR;
	uint32_t RESERVED;
	volatile uint32_t SECCFGR;
} GPIO_TypeDef;

typedef struct
{
	volatile uint32_t CR1;
	volatile uint32_t CR2;
	volatile uint32_t SMCR;
	volatile uint32_t DIER;
	volatile uint32_t SR;
	volatile uint32_t EGR;
	volatile uint32_t CCMR1;
	volatile uint32_t CCMR2;
	volatile uint32_t CCER;
	volatile uint32_t CNT;
	volatile uint32_t PSC;
	volatile uint32_t ARR;
	volatile uint32_t RCR;
	volatile uint32_t CCR1;
	volatile uint32_t CCR2;
	volatile uint32_t CCR3;
	volatile uint32_t CCR4;
	volatile uint32_t BDTR;
	volatile uint32_t DCR;
	volatile uint32_t DMAR;
	volatile uint32_t OR1;
	volatile uint32_t CCMR3;
	volatile uint32_t CCR5;
	volatile uint32_t CCR6;
	volatile uint32_t OR2;
	volatile uint32_t OR3;
} TIM_TypeDef;

#define RCC_AHB2ENR *((volatile uint32_t *)(0x40021000 + 0x4C))
#define RCC_APB1ENR1 *((volatile uint32_t *)(0x40021000 + 0x58))

#define GPIOA ((GPIO_TypeDef *)(0x42020000))
#define GPIOB ((GPIO_TypeDef *)(0x42020000 + 0x400))
// #define GPIOC ((GPIO_TypeDef *)(0x42020000 + 0x800))
// #define GPIOD ((GPIO_TypeDef *)(0x42020000 + 0xC00))
// #define GPIOE ((GPIO_TypeDef *)(0x42020000 + 0x1000))
// #define GPIOF ((GPIO_TypeDef *)(0x42020000 + 0x1400))

#define TIM6 ((TIM_TypeDef *)0x40001000)

void write_to_7s(uint32_t number)
{
static const uint32_t seven_segment[10]={0x3FU,0x06U,0x5BU,0x4FU,0x66U,0x6DU,0x7DU,0x07U,0x7FU,0x6FU};
 GPIOB->ODR &= ~(0xFFU); //clear the pin interface of 7S
 GPIOB->ODR |= seven_segment[number]; //write the digit to the pins
}

int main(void)
{
	RCC_AHB2ENR |= 0x111111 << 0;
	RCC_APB1ENR1 |= 1 << 4; // enable tim6

	// red led output
	GPIOA->MODER &= ~(0x03 << (9 * 2));
	GPIOA->MODER |= (0x01 << (9 * 2));

	GPIOB->MODER &= ~(0x03 << (7 * 2));
	GPIOB->MODER |= (0x01 << (7 * 2));

	GPIOA->MODER &= ~(0x03 << (8 * 2)); // Trigger PA8
	GPIOA->MODER |= (0x01 << (8 * 2));

	GPIOA->MODER &= ~(0x03 << (0 * 2)); // Echo PA0

	GPIOB->MODER &= ~(0x03 << (0 * 2));
	GPIOB->MODER |= (0x01 << (0 * 2));

	GPIOB->MODER &= ~(0x03 << (1 * 2));
	GPIOB->MODER |= (0x01 << (1 * 2));

	GPIOB->MODER &= ~(0x03 << (2 * 2));
	GPIOB->MODER |= (0x01 << (2 * 2));

	GPIOB->MODER &= ~(0x03 << (3 * 2));
	GPIOB->MODER |= (0x01 << (3 * 2));

	GPIOB->MODER &= ~(0x03 << (4 * 2));
	GPIOB->MODER |= (0x01 << (4 * 2));

	GPIOB->MODER &= ~(0x03 << (5 * 2));
	GPIOB->MODER |= (0x01 << (5 * 2));

	GPIOB->MODER &= ~(0x03 << (6 * 2));
	GPIOB->MODER |= (0x01 << (6 * 2));


	TIM6->PSC = 3;
	TIM6->CR1  = 0;
	TIM6->CR1 |= (0x01);

	//PC8, PC9, PC10, PC11, PC12, PD2, PF3, PF5

	while (1)
	{
		TIM6->ARR = 10;

		GPIOA->ODR |= 1 << 8;

		while (!(TIM6->SR & 0x01))
			;

		GPIOA->ODR &= ~(1 << 8);

		TIM6->SR = 0;
		TIM6->ARR = 65535;

		while (!(GPIOA->IDR & 0x01));

		uint32_t start_time = TIM6->CNT;

		while ((GPIOA->IDR & 0x01))
			;
		uint32_t end_time = TIM6->CNT;

		uint32_t distance = (end_time - start_time) / 58;

		if (distance < 10)
		{
			GPIOA->ODR |= 1 << 9;
			write_to_7s(distance);
		}
		else
		{
			GPIOA->ODR &= ~(1 << 9);
			GPIOB->ODR &= ~(0xFFU); //clear the pin interface of 7S
		}
	}
}
