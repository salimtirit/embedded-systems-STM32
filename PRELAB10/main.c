/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2022 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>

typedef struct
{
	volatile uint32_t MODER;
	volatile uint32_t OTYPER;
	volatile uint32_t OSPEEDR;
	volatile uint32_t PUPDR;
	volatile uint32_t IDR;
	volatile uint32_t ODR;
	volatile uint32_t BSRR;
	volatile uint32_t LCKR;
	volatile uint32_t AFRL;
	volatile uint32_t AFRH;
	volatile uint32_t BRR;
	uint32_t RESERVED;
	volatile uint32_t SECCFGR;
} GPIO_TypeDef;

typedef struct
{
	volatile uint32_t ISR;
	volatile uint32_t IER;
	volatile uint32_t CR;
	volatile uint32_t CFGR;
	volatile uint32_t CFGR2;
	volatile uint32_t SMPR1;
	volatile uint32_t SMPR2;
	uint32_t RESERVED1;
	volatile uint32_t TR1;
	volatile uint32_t TR2;
	volatile uint32_t TR3;
	uint32_t RESERVED2;
	volatile uint32_t SQR1;
	volatile uint32_t SQR2;
	volatile uint32_t SQR3;
	volatile uint32_t SQR4;
	volatile uint32_t DR;
	uint32_t RESERVED3[2];
	volatile uint32_t JSQR;
	uint32_t RESERVED4[4]; // 50
	volatile uint32_t OFR1;
	volatile uint32_t OFR2;
	volatile uint32_t OFR3;
	volatile uint32_t OFR4;
	uint32_t RESERVED5[4];
	volatile uint32_t JDR1;
	volatile uint32_t JDR2;
	volatile uint32_t JDR3;
	volatile uint32_t JDR4;
	uint32_t RESERVED6[4];
	volatile uint32_t AWD2CR;
	volatile uint32_t AWD3CR;
	uint32_t RESERVED7[2];
	volatile uint32_t DIFSEL;
	volatile uint32_t CALFACT;
} ADC_TypeDef;

typedef struct
{
	volatile uint32_t CR1;	 /*!< USART Control register 1,                    Address offset: 0x00 */
	volatile uint32_t CR2;	 /*!< USART Control register 2,                    Address offset: 0x04 */
	volatile uint32_t CR3;	 /*!< USART Control register 3,                    Address offset: 0x08 */
	volatile uint32_t BRR;	 /*!< USART Baud rate register,                    Address offset: 0x0C */
	volatile uint32_t GTPR;	 /*!< USART Guard time and prescaler register,     Address offset: 0x10 */
	volatile uint32_t RTOR;	 /*!< USART Receiver Time Out register,            Address offset: 0x14 */
	volatile uint32_t RQR;	 /*!< USART Request register,                      Address offset: 0x18 */
	volatile uint32_t ISR;	 /*!< USART Interrupt and status register,         Address offset: 0x1C */
	volatile uint32_t ICR;	 /*!< USART Interrupt flag Clear register,         Address offset: 0x20 */
	volatile uint32_t RDR;	 /*!< USART Receive Data register,                 Address offset: 0x24 */
	volatile uint32_t TDR;	 /*!< USART Transmit Data register,                Address offset: 0x28 */
	volatile uint32_t PRESC; /*!< USART Prescaler register,                    Address offset: 0x2C */
} LPUART_TypeDef;

typedef struct
{
	volatile uint32_t CR1; // 0x00
	volatile uint32_t CR2;
	volatile uint32_t SMCR;
	volatile uint32_t DIER;
	volatile uint32_t SR; // 0x10
	volatile uint32_t EGR;
	volatile uint32_t CCMR1;
	volatile uint32_t CCMR2;
	volatile uint32_t CCER; // 0x20
	volatile uint32_t CNT;
	volatile uint32_t PSC;
	volatile uint32_t ARR;
	volatile uint32_t RCR; // 0x30
	volatile uint32_t CCR1;
	volatile uint32_t CCR2;
	volatile uint32_t CCR3;
	volatile uint32_t CCR4; // 0x40
	uint32_t reserved1;
	volatile uint32_t DCR;
	volatile uint32_t DMAR;
	volatile uint32_t OR1; // 0x50
	uint32_t reserved2;
	uint32_t reserved3;
	uint32_t reserved4;
	volatile uint32_t OR2; // 0x60
	uint32_t reserved5;
} TIM_TypeDef;

#define RCC_AHB2ENR *((volatile uint32_t *)(0x40021000 + 0x4C))
#define RCC_APB1ENR1 *((volatile uint32_t *)(0x40021000 + 0x58))
#define RCC_APB1ENR2 *((volatile uint32_t *)(0x40021000 + 0x5C))
#define RCC_CCIPR1 *((volatile uint32_t *)(0x40021000 + 0x088))
#define NVIC_ISER1 *((volatile uint32_t *)(0xE000E100 + 0x4))
#define NVIC_ISER2 *((volatile uint32_t *)(0xE000E100 + 0x8))
#define PWR_CR1 *((volatile uint32_t *)(0x40007000))
#define PWR_CR2 *((volatile uint32_t *)(0x40007000 + 0x04))

#define GPIOA ((GPIO_TypeDef *)(0x42020000))
// #define GPIOB ((GPIO_TypeDef *)(0x42020000 + 0x400))
// #define GPIOC ((GPIO_TypeDef *)(0x42020000 + 0x800))
#define GPIOG ((GPIO_TypeDef *)(0x42020000 + 0x1800))
#define ADC1 ((ADC_TypeDef *)(0x42020000 + 0x8000))
#define LPUART1 ((LPUART_TypeDef *)(0x40008000))
#define TIM5 ((TIM_TypeDef *)0x40000C00)

void write(uint32_t value)
{
	uint32_t ascii_zero = 48;

	if (value > 999)
	{
		uint32_t binler = value / 1000;
		uint32_t yuzler = (value % 1000) / 100;
		uint32_t onlar = (value % 100) / 10;
		uint32_t birler = value % 10;

		LPUART1->TDR = binler + ascii_zero;
		LPUART1->TDR = yuzler + ascii_zero;
		LPUART1->TDR = onlar + ascii_zero;
		LPUART1->TDR = birler + ascii_zero;
		LPUART1->TDR = '\r';
		LPUART1->TDR = '\n';
	}
	else if (value > 99)
	{
		uint32_t yuzler = (value % 1000) / 100;
		uint32_t onlar = (value % 100) / 10;
		uint32_t birler = value % 10;
		LPUART1->TDR = yuzler + ascii_zero;
		LPUART1->TDR = onlar + ascii_zero;
		LPUART1->TDR = birler + ascii_zero;
		LPUART1->TDR = '\r';
		LPUART1->TDR = '\n';
	}
	else if (value > 9)
	{
		uint32_t onlar = (value % 100) / 10;
		uint32_t birler = value % 10;
		LPUART1->TDR = onlar + ascii_zero;
		LPUART1->TDR = birler + ascii_zero;
		LPUART1->TDR = '\r';
		LPUART1->TDR = '\n';
	}
	else
	{
		uint32_t birler = value % 10;
		LPUART1->TDR = birler + ascii_zero;
		LPUART1->TDR = '\r';
		LPUART1->TDR = '\n';
	}
}

void ADC1_2_IRQHandler()
{
	uint32_t value = ADC1->DR; // 4034 0
	// write(value);

	ADC1->CR |= (0x01 << 2);
}

void TIM5_IRQHandler(void)
{
	TIM5->SR = 0;
	uint32_t value = ADC1->DR; // 4034 0
	write(value);
}


void LPUART1_IRQHandler()
{
}


void init_TIM5()
{
	RCC_APB1ENR1 |= 1 << 3; // enable tim5
	TIM5->PSC = 4000 - 1;	// Configure prescaler to increase the CNT register for every 1 millisecond TIM5
	TIM5->CR1 &= ~(1 << 1); // OVF will generate an event
	// TIM6 Interrupt Initialization
	TIM5->ARR = 4999;	  // general 1Hz
	TIM5->SR = 0;		  // general
	TIM5->DIER |= (0x01); // Enable update interrupt TIM5
	NVIC_ISER1 |= (1 << 16);
	TIM5->CR1 |= (1); // Counter Enable
}


int main(void)
{
	// delete start
	RCC_AHB2ENR |= (0x01 << 0); // gpio a b c enable
	// PA9 red make all 0
	GPIOA->MODER &= ~(3 << (9 * 2));
	// PA9 red make 01
	GPIOA->MODER |= (1 << (9 * 2));
	// delete end

	// Enable Clock for Power Interface
	RCC_APB1ENR1 |= (0x1 << 28);

	// Enable Clock for ADC
	RCC_AHB2ENR |= (0x1 << 13);

	// Change the regulator mode to Low-power mode
	PWR_CR1 |= (0x1 << 14);

	// Make VDDIO2 valid
	PWR_CR2 |= (0x1 << 9);

	// Change the clock source of Low-power UART to SYSCLK
	RCC_CCIPR1 &= ~(0x3 << 10);
	RCC_CCIPR1 |= (0x1 << 10);

	// Select ADC clock as System clock
	RCC_CCIPR1 |= (0x03 << 28);

	// Enable Clock for Low-power UART
	RCC_APB1ENR2 |= (0x1 << 0);

	// Enable Clock for GPIO
	RCC_AHB2ENR |= (0x01 << 6); // GPIOG enable

	// Change the functionality of the pin
	GPIOG->MODER &= ~(0x3 << 7 * 2);
	GPIOG->MODER |= (0x1 << 15);

	GPIOG->MODER &= ~(0x3 << 8 * 2);
	GPIOG->MODER |= (0x1 << 17);

	// Low 0010 AF2
	GPIOG->AFRL &= ~(0xF << 28);
	GPIOG->AFRL |= (1 << 31);

	// High 0010 AF2
	GPIOG->AFRH &= ~(0xF << 0);
	GPIOG->AFRH |= (1 << 3);

	// Change Regular channel sequence length to 1 conversion
	ADC1->SQR1 &= ~(0x0F << 0);

	// Add to channel to first sequence
	ADC1->SQR1 |= 0x1 << 6;

	// Disable Deep-power-down for ADC
	ADC1->CR &= ~(0x1 << 29);

	// Enable ADC Voltage regulator
	ADC1->CR |= (0x1 << 28);

	// Configure for Single conversion mode
	ADC1->CFGR &= ~(0x1 << 13);

	// Enable ADC
	ADC1->CR |= (0x1 << 0);

	// Wait ADC is enabled
	while (!(ADC1->ISR & 0x01))
	{
	}

	// Enable interrupt for end of regular conversion
	ADC1->IER |= (0x1 << 2);

	// Change LPUART baud rate (BRR) for 9600 Baud rate
	LPUART1->BRR |= 106667; // 106 667

	// Enable FIFO mode for UART
	LPUART1->CR1 |= 0x1 << 29;

	// Enable Transmitter and Receiver for UART
	LPUART1->CR1 |= 0x1 << 2;
	LPUART1->CR1 |= 0x1 << 3;

	// Enable Interrupt and LPUART
	LPUART1->CR1 |= 0x1 << 6;
	// LPUART1->CR1 |= 0x1 << 5; //receive

	NVIC_ISER1 |= (0x1 << 5); // ADC1
	NVIC_ISER2 |= (0x1 << 1); // LPUART

	__asm volatile( // enable all interrupts that are configured
		"mov r0, #0 \n\t"
		"msr primask, r0 \n\t");

	init_TIM5();
	// Start regular conversion of ADC
	ADC1->CR |= (0x1 << 2);

	LPUART1->CR1 |= 0x1 << 0;

	while (1)
	{
	}
}
