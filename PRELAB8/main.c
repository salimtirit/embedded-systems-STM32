/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2022 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>

typedef struct
{
	volatile uint32_t MODER;
	volatile uint32_t OTYPER;
	volatile uint32_t OSPEEDR;
	volatile uint32_t PUPDR;
	volatile uint32_t IDR;
	volatile uint32_t ODR;
	volatile uint32_t BSRR;
	volatile uint32_t LCKR;
	volatile uint32_t AFRL;
	volatile uint32_t AFRH;
	volatile uint32_t BRR;
	uint32_t RESERVED;
	volatile uint32_t SECCFGR;
} GPIO_TypeDef;

typedef struct
{
	volatile uint32_t CR1; // 0x00
	volatile uint32_t CR2;
	volatile uint32_t SMCR;
	volatile uint32_t DIER;
	volatile uint32_t SR; // 0x10
	volatile uint32_t EGR;
	volatile uint32_t CCMR1;
	volatile uint32_t CCMR2;
	volatile uint32_t CCER; // 0x20
	volatile uint32_t CNT;
	volatile uint32_t PSC;
	volatile uint32_t ARR;
	volatile uint32_t RCR; // 0x30
	volatile uint32_t CCR1;
	volatile uint32_t CCR2;
	volatile uint32_t CCR3;
	volatile uint32_t CCR4; // 0x40
	uint32_t reserved1;
	volatile uint32_t DCR;
	volatile uint32_t DMAR;
	volatile uint32_t OR1; // 0x50
	uint32_t reserved2;
	uint32_t reserved3;
	uint32_t reserved4;
	volatile uint32_t OR2; // 0x60
	uint32_t reserved5;
} TIM_TypeDef;

#define RCC_AHB2ENR *((volatile uint32_t *)(0x40021000 + 0x4C))
#define RCC_APB1ENR1 *((volatile uint32_t *)(0x40021000 + 0x58))

#define GPIOA ((GPIO_TypeDef *)(0x42020000))
// #define GPIOB ((GPIO_TypeDef *)(0x42020000 + 0x400))
// #define GPIOC ((GPIO_TypeDef *)(0x42020000 + 0x800))
#define GPIOD ((GPIO_TypeDef *)(0x42020000 + 0xC00))
// #define GPIOE ((GPIO_TypeDef *)(0x42020000 + 0x1000))
// #define GPIOF ((GPIO_TypeDef *)(0x42020000 + 0x1400))

#define TIM2 ((TIM_TypeDef *)0x40000000)
#define TIM3 ((TIM_TypeDef *)0x40000400)
#define TIM4 ((TIM_TypeDef *)0x40000800)
#define TIM5 ((TIM_TypeDef *)0x40000C00)

#define NVIC_ISER1 *((volatile uint32_t *)(0xE000E100 + 0x04))

// PD7 blue
// PD6 green
// PD5 red
// PD4 input

uint32_t state;
uint32_t i = 0;

#define HI 1
#define LO 0
static uint16_t edgefirst, pulsewidth; 

// green
void TIM3_IRQHandler(void)
{
	TIM3->SR = 0;
	TIM3->CCR1 += pulsewidth;
}

// blue
void TIM4_IRQHandler(void)
{
	static unsigned int ic_pin = LO;
	if (ic_pin == LO) // HI has come
	{
		ic_pin = HI;
		edgefirst = TIM4->CCR1;
	}
	else // LO has come
	{
		ic_pin = LO;
		pulsewidth = TIM4->CCR1 - edgefirst;
	}
	TIM3->CCR1 = TIM3->CNT + pulsewidth;
}

void init_TIM3()
{
	RCC_APB1ENR1 |= 1 << 1; // enable tim3
	TIM3->EGR |= (0x01);	// Generate update interrupt when CNT is reinitialized TIM3
	TIM3->PSC = 20000 - 1;	// Configure prescaler to increase the CNT register for every 2 millisecond TIM3
	TIM3->CR1 &= ~(1 << 1); // OVF will generate an event
		
	TIM3->SR = 0;		  // green
	TIM3->DIER |= (0x01 << 1); // Enable capture compare interrupt TIM3

	// TIM3->CCMR1 &= ~(0x3 << 0);
	TIM3->CCMR1 &= ~(0x7 << 4);
	TIM3->CCMR1 &= ~(0x1 << 16);
	TIM3->CCMR1 |= (0x3 << 4);

	TIM3->CCER |= (0x1 << 0);

	NVIC_ISER1 |= (1 << 14);

	TIM3->CR1 |= (1); // Counter Enable
}

void init_TIM4()
{
	RCC_APB1ENR1 |= 1 << 2; // enable tim4
	TIM4->EGR |= (0x01);	// Generate update interrupt when CNT is reinitialized TIM4
	TIM4->PSC = 8000 - 1;	// Configure prescaler to increase the CNT register for every 2 millisecond TIM4
	TIM4->CR1 &= ~(1 << 1); // OVF will generate an event
	// TIM6 Interrupt Initialization
	TIM4->ARR = 0xFFFF; // 2;		  // blue 400Hz

	TIM4->CCMR1 &= ~(0x03 << 0);
	TIM4->CCMR1 |= (0x1 << 0);

	TIM4->SR = 0;			   // blue
	TIM4->DIER |= (0x01 << 1); // Enable capture compare interrupt TIM4

	TIM4->CCMR1 &= ~(0x3 << 0);
	TIM4->CCMR1 |= (0x1 << 0);

	TIM4->CCER |= (0x1 << 0);

	NVIC_ISER1 |= (1 << 15); // Enable IRQ for Timer

	TIM4->CR1 |= (1); // Counter Enable
}

int main(void)
{
	RCC_AHB2ENR |= 1 << 0; // 1 << 3; // gpioden
	RCC_AHB2ENR |= 1 << 3; // 1 << 3; // gpioden

	// PD12 input for the switch
	GPIOD->MODER &= ~(0x03 << (12 * 2));
	GPIOD->MODER |= (0x02 << (12 * 2));

11111110 11111111 11111111 11111111
10101011 11111111 11011111 11111111
	// High 0010 AF2
	GPIOD->AFRH &= ~(0x0F << 16);
	GPIOD->AFRH |= (0x02 << 16);

	// Low 0010 AF2
	GPIOA->AFRL &= ~(0x0F << 24);
	GPIOA->AFRL |= (0x02 << 24);

	// red led output
	GPIOA->MODER &= ~(0x03 << (6 * 2));
	GPIOA->MODER |= (0x01 << (6 * 2));

	__asm volatile( // enable all interrupts that are configured
		"mov r0, #0 \n\t"
		"msr primask, r0 \n\t");

	init_TIM3();
	init_TIM4();

	GPIOD->ODR = 1;
}
